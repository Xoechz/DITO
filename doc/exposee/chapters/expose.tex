\chapter{Exposé}

\section{Motivation}

\subsection{TO BE DELETED: NOTES}

\begin{itemize}
	\item Current State of OTEL and a future of very probable mass adoption(with citations)
	\item OTEL not only in Microservices, but all distributed systems. Company wide observability
	\item Transition to the problem, mentioning services which transfer a lot of data
\end{itemize}

\subsection{ACTUAL TEXT}

OpenTelemetry has established itself as a groundbreaking new standard in the world of observability.
It is replacing many vendor specific solutions with a single, standardized, extensible, open source
and language integrated solution.

OpenTelemetry has been designed with microservices in mind, but it is not exclusive to microservices.
Distributed systems of all kinds, even legacy systems, can profit of OpenTelemetry. 

\section{Problem}

\subsection{TO BE DELETED: NOTES}

\begin{itemize}
	\item Fractured company software systems with multiple sources of truth.
	\item Merging and transferring data across multiple systems.
	\item Inconsistent data
	\item Notifying admins of the different single systems about data quality.
	\item Concrete Problem - try to explain swietelsky hell
\end{itemize}

\subsection{ACTUAL TEXT}

A big problem in legacy systems, especially naturally grown ones, is that often no single source of truth exists.
So data entries, like employee data, are often stored in multiple loosely connected sub systems.
For example the information which employee has which manager could be stored in another subsystem
as the information in which team an employee is working. Issues like these are often structural
and can not directly and immediately be influenced by the developers tasked with dealing with the system.
Unifying the data sources and saving them in a centralized system is a tedious and long undertaking,
requiring the whole companies effort to clean up past technical dept and incorrect data.

To keep the company operational while this is and to migrate the system step by step, 
the data from the legacy sources needs to be synced with the new system, but there are bound to be mismatches, 
invalid states and other errors, due to no single source of truth existing.
These issues can often take a long time to fix, but they should not stop the entire syncing process.
The developers and decision makers do however need to be informed when, for how long and why errors are happening,
without having to click through every applications logs.

\section{Goals}

\subsection{TO BE DELETED: NOTES}

\begin{itemize}
	\item Explain Traces and Metrics in the context of OpenTelemetry.
	\item Explain Collectors, their use, components and different types of Collectors.
	\item Write a Collector in GO and generate traces in a .NET Application to
	      \begin{itemize}
		      \item Provide an overview over the data quality in the system.
		      \item See where errors are happening and what their source could be.
		      \item Have traces for every data point travelling through a system, next to the traces per job execution.
		      \item Metrics which are able to be grouped by source, destination, entity being synced, job or machine executing the job.
	      \end{itemize}
	\item do that a bit more and a bit better lol
\end{itemize}

\subsection{ACTUAL TEXT}

To help getting through this chaos, all the observability data, meaning logs, traces and metrics, should be
collected to a single dashboard showing all the issues and the performance of the whole system.

This alone is easily achieved using simple zero-code instrumentation and a telemetry backend of your choice
like Jaeger, Zipkin, Prometheus or in this case Microsoft Application Insights.

WOS DRAUM SCHWA IS; WOS AUSAKEMMA SOI UND WIE I DES LÖS MIT COLLECTOREN UND SO

\section{Methodic ODA SO IRGENDWIE}

\subsection{TO BE DELETED: NOTES}

\begin{itemize}
	\item Explain Techstack(.net, golang)
	\item Talk about Prototype and results
\end{itemize}

\subsection{ACTUAL TEXT}
